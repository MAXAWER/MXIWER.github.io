<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MThread Messenger</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style> ... </style>
</head>
<body>
    <script type="module">
      // --- ИМПОРТЫ ---
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
      import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
      import { getDatabase, ref, set, get, onValue, push, query, orderByChild, equalTo, serverTimestamp, update, startAt, endAt } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
      import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-messaging.js";

      // --- КОНФИГУРАЦИЯ И ИНИЦИАЛИЗАЦИЯ ---
      const firebaseConfig = { /* ... ВАШ КОНФИГ ... */ };
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getDatabase(app);
      const messaging = getMessaging(app);
      // ... остальные переменные ...
      
      // --- ЛОГИКА PUSH-УВЕДОМЛЕНИЙ ---
      async function setupNotifications(user) {
          try {
              const permission = await Notification.requestPermission();
              if (permission === 'granted') {
                  console.log('Notification permission granted.');
                  const fcmToken = await getToken(messaging, { vapidKey: 'ВАШ_VAPID_КЛЮЧ_ИЗ_НАСТРОЕК_FIREBASE_MESSAGING' });
                  if (fcmToken) {
                      console.log('FCM Token:', fcmToken);
                      const tokensRef = ref(db, `users/${user.uid}/fcmTokens/${fcmToken}`);
                      await set(tokensRef, true); // Сохраняем токен в базе
                  } else {
                      console.log('No registration token available. Request permission to generate one.');
                  }
              } else {
                  console.log('Unable to get permission to notify.');
              }
          } catch (error) {
              console.error('An error occurred while setting up notifications:', error);
          }
      }

      // Слушаем входящие сообщения, когда приложение активно
      onMessage(messaging, (payload) => {
          console.log('Message received. ', payload);
          // Здесь можно показать кастомное уведомление внутри приложения
          const notificationTitle = payload.notification.title;
          const notificationOptions = { body: payload.notification.body, icon: payload.notification.icon };
          // new Notification(notificationTitle, notificationOptions); // Можно, но лучше не показывать, если вкладка активна
      });

      // --- ЛОГИКА АУТЕНТИФИКАЦИИ ---
      onAuthStateChanged(auth, async user => {
          if (user) {
              // ...
              if (snapshot.exists() && snapshot.val().nickname) {
                  showChatInterface(snapshot.val());
                  setupNotifications(user); // <--- ЗАПРАШИВАЕМ РАЗРЕШЕНИЕ НА УВЕДОМЛЕНИЯ
              } else {
                  // ...
              }
          }
          // ...
      });

      // --- НОВЫЙ ПОИСК ПОЛЬЗОВАТЕЛЕЙ (БЕЗ ПРЕДЗАГРУЗКИ) ---
      userSearchInput.addEventListener('input', (e) => {
          const searchTerm = e.target.value.toLowerCase();
          if (searchTerm.length < 2) {
              userSearchList.innerHTML = '<p style="padding: 10px; color: var(--text-light);">Введите минимум 2 символа для поиска</p>';
              return;
          }
          searchUsers(searchTerm);
      });

      async function searchUsers(searchTerm) {
          const usersQuery = query(ref(db, 'users'), orderByChild('nickname'), startAt(searchTerm), endAt(searchTerm + '\uf8ff'));
          const snapshot = await get(usersQuery);
          userSearchList.innerHTML = '';
          if (snapshot.exists()) {
              const searchResult = snapshot.val();
              Object.entries(searchResult).forEach(([uid, user]) => {
                  if (uid !== currentUser.uid) renderUserListItem(uid, user);
              });
          } else {
              userSearchList.innerHTML = '<p style="padding: 10px; color: var(--text-light);">Пользователи не найдены.</p>';
          }
      }
      
      // --- ЛОГИКА ГРУПП ---
      // ... (Добавить HTML для кнопки "Создать группу" и модального окна)
      // document.getElementById('create-group-button').addEventListener('click', () => { /* открыть модал */ });
      
      // Логика создания группы
      async function createGroup(groupName, memberUids) {
          const groupRef = push(ref(db, 'groups')); // Генерируем новый ID для группы
          const groupId = groupRef.key;
          
          const members = {};
          members[currentUser.uid] = { role: 'admin' }; // Создатель - админ
          memberUids.forEach(uid => {
              if (uid !== currentUser.uid) members[uid] = { role: 'member' };
          });

          await set(groupRef, {
              name: groupName,
              createdBy: currentUser.uid,
              timestamp: serverTimestamp(),
              members: members
          });
          
          // Также создаем запись в /chats для отображения в списке
          await set(ref(db, `chats/${groupId}`), {
             isGroup: true,
             name: groupName,
             timestamp: serverTimestamp()
          });
      }

      // ... И ДРУГИЕ ОБНОВЛЕНИЯ В КОДЕ ДЛЯ ПОДДЕРЖКИ ГРУПП ...
    </script>
</body>
</html>
