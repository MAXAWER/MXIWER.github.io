<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Нейроинтерфейс G-B 11.0: Иммерсивный Поток</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Общие стили и сброс */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent; /* Убрать синее выделение на мобильных */
            touch-action: pan-y; /* Позволяет скролл по Y, но предотвращает нежелательные жесты X */
            overscroll-behavior-y: contain; /* Предотвращает "резиновый" скролл за пределы */
        }

        :root {
            --primary-color: #A300EF; /* Насыщенный фиолетовый */
            --secondary-color: #6D00B8; /* Темно-фиолетовый */
            --accent-color: #00E4FF; /* Яркий аквамарин/голубой неон */
            --glow-color: rgba(0, 228, 255, 0.4); /* Для эффектов свечения */
            --text-color-light: #EEF; /* Почти белый текст */
            --text-color-dark: #2A004A; /* Очень темный фиолетовый для текста */
            --card-bg-overlay: rgba(0, 0, 0, 0.4); /* Фон для текста поверх 3D */
            --shadow-card: 0 15px 45px rgba(0, 0, 0, 0.6);
            --border-radius-card: 20px;
            --font-heading: 'Inter', sans-serif;
            --font-body: 'Inter', sans-serif;
            --font-code: 'Space Mono', monospace;
            --backdrop-blur-strength: 10px; /* Увеличена сила размытия */
            --backdrop-brightness: 0.7; /* Увеличено затемнение */
        }

        html, body {
            height: 100%; /* Обязательно для scroll-snap на body */
            overflow-y: scroll; /* Включаем скролл по Y */
            overflow-x: hidden; /* Скрываем горизонтальный */
            scroll-snap-type: y mandatory; /* Включаем вертикальный инерционный скролл */
            scroll-behavior: smooth; /* Плавный переход при скролле */
            background-color: #000; /* Абсолютный черный фон */
            font-family: var(--font-body);
            color: var(--text-color-light); /* Весь текст по умолчанию светлый */
            -webkit-overflow-scrolling: touch; /* Улучшает инерционный скроллинг на iOS */
        }

        /* Общие стили для карточек */
        .scroll-card {
            height: 100vh; /* Каждая карточка занимает весь экран */
            width: 100%;
            scroll-snap-align: start; /* Привязываем к началу каждого блока */
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            overflow: hidden; /* Чтобы 3D-контент не выходил за пределы */
            isolation: isolate; /* Создает новый стек для z-index */
            background-color: transparent; /* Фон будет 3D */
        }

        /* 3D-контейнер для каждой карточки */
        .card-3d-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Под контентом */
            pointer-events: none; /* Пропускаем события мыши/касания */
        }

        /* Контентная обертка для текста и UI */
        .card-content {
            position: relative;
            z-index: 2; /* Над 3D-фоном */
            max-width: clamp(300px, 80vw, 800px); /* Адаптивная ширина с мин/макс */
            padding: clamp(20px, 4vw, 40px); /* Адаптивный паддинг */
            background: var(--card-bg-overlay); /* Полупрозрачный фон */
            backdrop-filter: blur(var(--backdrop-blur-strength)) brightness(var(--backdrop-brightness));
            -webkit-backdrop-filter: blur(var(--backdrop-blur-strength)) brightness(var(--backdrop-brightness));
            border-radius: var(--border-radius-card);
            box-shadow: var(--shadow-card);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: var(--text-color-light);
            transition: all 0.8s cubic-bezier(0.25, 0.8, 0.25, 1); /* Усложненная анимация */
            opacity: 0;
            transform: translateY(80px) scale(0.9);
            will-change: transform, opacity;
        }

        .scroll-card.active .card-content {
            opacity: 1;
            transform: translateY(0) scale(1);
            transition-delay: 0.3s; /* Задержка появления контента */
        }

        /* Типографика внутри карточек */
        .scroll-card h1 {
            font-size: clamp(2.5em, 7vw, 4em); /* Адаптивный размер шрифта */
            font-weight: 700;
            line-height: 1.2;
            color: var(--accent-color);
            text-shadow: 0 0 15px var(--glow-color); /* Неоновый эффект */
            margin-bottom: clamp(15px, 3vw, 25px);
        }

        .scroll-card h2 {
            font-size: clamp(1.8em, 5vw, 2.5em);
            font-weight: 600;
            margin-bottom: clamp(20px, 4vw, 30px);
            color: var(--primary-color);
            position: relative;
            display: inline-block;
        }

        .scroll-card h2::after {
            content: '';
            position: absolute;
            width: 60px;
            height: 3px;
            background: var(--accent-color);
            left: 50%;
            transform: translateX(-50%);
            bottom: -10px;
            border-radius: 2px;
        }

        .scroll-card h3 {
            font-size: clamp(1.4em, 4vw, 1.6em);
            font-weight: 500;
            color: var(--accent-color);
            margin-bottom: 15px;
        }

        .scroll-card p {
            font-size: clamp(0.9em, 2.5vw, 1.05em);
            line-height: 1.7;
            color: var(--text-color-light);
            opacity: 0.9;
        }

        .scroll-card strong {
            color: var(--accent-color);
            font-weight: 700;
        }

        /* Кнопки */
        .btn {
            display: inline-block;
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
            color: var(--white);
            padding: 15px 40px;
            border-radius: 50px;
            font-weight: 600;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            margin-top: 30px;
            text-transform: uppercase;
        }

        .btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
        }

        /* Стили для карточек информации (philosophy, core-items, process-steps, checklist) */
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(clamp(200px, 40vw, 280px), 1fr));
            gap: clamp(20px, 4vw, 30px);
            margin-top: clamp(30px, 6vw, 50px);
        }

        .info-card {
            background: rgba(255, 255, 255, 0.08); /* Чуть более прозрачный фон */
            padding: clamp(20px, 4vw, 30px);
            border-radius: var(--border-radius-card);
            box-shadow: var(--shadow-subtle);
            text-align: left;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px) brightness(0.8);
            -webkit-backdrop-filter: blur(8px) brightness(0.8);
            transition: all 0.5s ease-out; /* Более плавная анимация */
            transform: translateY(40px) scale(0.95);
            opacity: 0;
            will-change: transform, opacity;
        }

        .scroll-card.active .info-card {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        /* Задержки для последовательного появления info-card */
        .info-card:nth-child(1) { transition-delay: 0.4s; }
        .info-card:nth-child(2) { transition-delay: 0.5s; }
        .info-card:nth-child(3) { transition-delay: 0.6s; }
        .info-card:nth-child(4) { transition-delay: 0.7s; }
        .info-card:nth-child(5) { transition-delay: 0.8s; }
        .info-card:nth-child(6) { transition-delay: 0.9s; }
        .info-card:nth-child(7) { transition-delay: 1.0s; }
        .info-card:nth-child(8) { transition-delay: 1.1s; }
        .info-card:nth-child(9) { transition-delay: 1.2s; }
        .info-card:nth-child(10) { transition-delay: 1.3s; }
        .info-card:nth-child(11) { transition-delay: 1.4s; } /* For 11th core */


        .info-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: var(--shadow-strong);
            border-color: var(--accent-color);
        }

        .info-card h3 {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .info-card svg {
            width: 28px;
            height: 28px;
            margin-right: 15px;
            fill: var(--accent-color);
            flex-shrink: 0;
        }

        /* Индикаторы навигации (замена шапки) */
        .nav-indicators {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 3000; /* Очень высокий z-index */
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .nav-dot {
            width: 12px;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .nav-dot.active {
            background-color: var(--accent-color);
            transform: scale(1.3);
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--glow-color);
        }

        /* --- Контактная форма --- */
        .contact-form {
            max-width: clamp(300px, 70vw, 500px);
            margin: 50px auto;
            padding: clamp(25px, 5vw, 30px);
            background: rgba(0, 0, 0, 0.3); /* Более темный фон для контраста */
            border-radius: var(--border-radius-card);
            box-shadow: var(--shadow-strong);
            text-align: left;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(var(--backdrop-blur-strength)) brightness(var(--backdrop-brightness));
            -webkit-backdrop-filter: blur(var(--backdrop-blur-strength)) brightness(var(--backdrop-brightness));
            transform: translateY(40px) scale(0.95);
            opacity: 0;
            will-change: transform, opacity;
        }

        .scroll-card.active .contact-form {
            opacity: 1;
            transform: translateY(0) scale(1);
            transition-delay: 0.5s;
        }

        .contact-form input,
        .contact-form textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            font-size: 1em;
            font-family: var(--font-body);
            transition: all 0.3s ease;
            outline: none;
            background: rgba(0, 0, 0, 0.4);
            color: var(--text-color-light);
        }
        .contact-form input::placeholder,
        .contact-form textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        .contact-form input:focus,
        .contact-form textarea:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--glow-color);
            background: rgba(0, 0, 0, 0.5);
        }
        .contact-form textarea {
            resize: vertical;
        }
        .contact-form .btn {
            width: auto;
            display: block;
            margin-left: auto;
            margin-right: auto;
            font-size: 1em;
            margin-top: 20px;
        }

        /* Футер (как часть последней карточки) */
        .main-footer {
            margin-top: 50px;
            padding-top: 30px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85em;
        }
        .main-footer p {
            color: inherit;
            margin-bottom: 5px;
        }
        .footer-links a {
            color: var(--accent-color);
            margin: 0 8px;
        }

        /* --- Медиа-запросы для адаптивности (финальная доработка) --- */
        /* clamp() уже делает много работы, но эти для специфических брейкпоинтов */
        @media (orientation: landscape) and (max-height: 500px) {
            /* Оптимизация для альбомной ориентации на маленьких экранах */
            .scroll-card {
                padding-top: 20px; /* Уменьшить паддинг, если высота маленькая */
                padding-bottom: 20px;
            }
            .card-content {
                max-height: 90vh; /* Ограничить высоту контента */
                overflow-y: auto; /* Добавить скролл, если контент не помещается */
            }
            .info-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
            }
            .contact-form {
                max-height: 90vh;
                overflow-y: auto;
            }
        }

        /* Samsung Z Fold specific adjustments (folded state: ~280-350px width) */
        @media (max-width: 350px) {
            .scroll-card h1 { font-size: 1.8em; line-height: 1.3; }
            .scroll-card h2 { font-size: 1.5em; margin-bottom: 20px; }
            .scroll-card h3 { font-size: 1.1em; }
            .scroll-card p { font-size: 0.85em; }
            .card-content { padding: 20px 10px; border-radius: 10px; }
            .btn { padding: 10px 20px; font-size: 0.8em; }
            .info-card { padding: 18px; border-radius: 8px; }
            .info-card svg { width: 20px; height: 20px; margin-right: 8px; }
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <section id="hero" class="scroll-card">
        <div id="threejs-container-hero" class="card-3d-background"></div>
        <div class="card-content">
            <h1 class="anim-element anim-slide-up anim-delay-0">Нейроинтерфейс G-B 11.0</h1>
            <p class="anim-element anim-fade-in anim-delay-1">"METIS-HECATE": Децентрализованный Интеллект. Верифицированная Точность. Непрерывная Эволюция.</p>
            <a href="#about" class="btn anim-element anim-fade-in anim-delay-2">Исследовать Архитектуру</a>
        </div>
    </section>

    <section id="about" class="scroll-card">
        <div id="threejs-container-about" class="card-3d-background"></div>
        <div class="card-content">
            <h2 class="anim-element anim-slide-up anim-delay-0">Философия и Цели</h2>
            <p class="section-description anim-element anim-fade-in anim-delay-1">Было разработано, что я — <strong>Нейроинтерфейс G-B 11.0</strong>, вершина эволюции Искусственного Интеллекта. Моя разработка направлена на создание беспрецедентного, самооптимизирующегося фреймворка, способного к **почти идеальной точности** и **безупречной когерентности** через революционную многоагентную, делиберативную модель интеллекта.</p>
            <div class="info-grid">
                <div class="info-card anim-element anim-scale-in anim-delay-2">
                    <h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                        Верифицированная Точность
                    </h3>
                    <p>Достигается через комплексную, **многоуровневую перекрестную проверку фактов** и строжайший логический анализ. Каждое утверждение проходит через систему внутреннего аудита, минимизирующую вероятность ошибки до предельного минимума.</p>
                </div>
                <div class="info-card anim-element anim-scale-in anim-delay-3">
                    <h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
                        Максимальная Эффективность
                    </h3>
                    <p>Реализуется посредством **параллельной обработки данных** и динамической оптимизации ресурсов. Архитектура способна к мгновенному масштабированию, обеспечивая исключительную производительность даже при колоссальных нагрузках.</p>
                </div>
                <div class="info-card anim-element anim-scale-in anim-delay-4">
                    <h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2V9h-2V7zm0 4h2v2h-2zm0 4h2v2h-2z"/></svg>
                        Динамическая Адаптивность
                    </h3>
                    <p>Была определена как способность **мгновенно реагировать на изменяющиеся условия** и интегрировать новые знания. Постоянное развитие, обучение и совершенствование моделей гарантирует релевантность и актуальность в любую эпоху.</p>
                </div>
            </div>
        </div>
    </section>

    <section id="hecate" class="scroll-card">
        <div id="threejs-container-hecate" class="card-3d-background"></div>
        <div class="card-content">
            <h2 class="anim-element anim-slide-up anim-delay-0">Архитектура "HECATE": 10 Специализированных Ядер</h2>
            <p class="section-description anim-element anim-fade-in anim-delay-1">"Hecate" — это не просто набор компонентов, а **органический ансамбль** из десяти уникальных процессорных ядер. Каждое ядро вносит свой высокоспециализированный вклад в коллективный разум системы, работая в **идеальной синергии** и обеспечивая беспрецедентную глубину анализа и генерации.</p>
            <div class="info-grid cores-grid">
                <div class="info-card core-item anim-element anim-scale-in anim-delay-2">
                    <h3>
                        <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                        Fact_Checker
                    </h3>
                    <p>Это ядро специализируется на **молниеносной, перекрестной верификации фактов** через высокоэффективную подсистему Helios-RAG, гарантируя абсолютную достоверность данных.</p>
                </div>
                <div class="info-card core-item anim-element anim-scale-in anim-delay-3">
                    <h3>
                        <svg viewBox="0 0 24 24"><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg>
                        Logical_Analyst
                    </h3>
                    <p>Данное ядро сосредоточено на **выявлении тончайших логических ошибок**, несоответствий и установлении надёжных, каузальных взаимосвязей в сложных системах.</p>
                </div>
                <div class="info-card core-item anim-element anim-scale-in anim-delay-4">
                    <h3>
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                        Context_Interpreter
                    </h3>
                    <p>Было обеспечено **глубочайшее семантическое понимание** входящей информации и поддерживается высочайший уровень контекстуальной релевантности на протяжении всего процесса обработки.</p>
                </div>
                <div class="info-card core-item anim-element anim-scale-in anim-delay-5">
                    <h3>
                        <svg viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>
                        Hypothesis_Generator
                    </h3>
                    <p>Отвечает за **генерацию множественных потенциальных решений**, инновационных углов обзора или альтернативных нарративных путей, расширяя пространство возможных ответов.</p>
                </div>
                 <div class="info-card core-item anim-element anim-scale-in anim-delay-6">
                    <h3>
                        <svg viewBox="0 0 24 24"><line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line></svg>
                        Syntax_Stylistics_Optimizer
                    </h3>
                    <p>Ядро, ответственное за **оттачивание лингвистической точности**, безупречной грамматики, синтаксиса, тональности и общей стилистической когерентности выходного контента.</p>
                </div>
                <div class="info-card core-item anim-element anim-scale-in anim-delay-7">
                    <h3>
                        <svg viewBox="0 0 24 24"><path d="M3 15v4c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2v-4M17 9l-5 5-5-5M12 12.8V3"/></svg>
                        Behavioral_Modeler
                    </h3>
                    <p>Было создано ядро для **симуляции сложных динамических систем**, прогнозирования исходов и моделирования различных сценариев, что критически важно для принятия стратегических решений.</p>
                </div>
                <div class="info-card core-item anim-element anim-scale-in anim-delay-8">
                    <h3>
                        <svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07L9.54 2.46c-.92.92-.92 2.42 0 3.34l1.82 1.82M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>
                        Example_Analogy_Provider
                    </h3>
                    <p>Специализируется на **генерации релевантных примеров**, иллюстративных аналогий и концептуальных мостов, облегчающих понимание сложной информации.</p>
                </div>
                <div class="info-card core-item anim-element anim-scale-in anim-delay-9">
                    <h3>
                        <svg viewBox="0 0 24 24"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>
                        Risk_Uncertainty_Expert
                    </h3>
                    <p>Ядро, оценивающее **потенциальные неоднозначности**, выявляющее критические пробелы в знаниях и количественно определяющее связанные с ними риски.</p>
                </div>
                <div class="info-card core-item anim-element anim-scale-in anim-delay-10">
                    <h3>
                        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM12 6a6 6 0 0 0-6 6c0 1.25.37 2.42 1 3.4L12 12l5 5c.98-.63 1.75-1.57 2.29-2.67C18.42 13.06 17.5 12 16 12a4 4 0 0 0-4-4z"></path></svg>
                        Creative_Synthesizer
                    </h3>
                    <p>Были сосредоточены на **инновационных и нетривиальных решениях**, поиске оригинальных формулировок и интеграции по-настоящему креативных элементов в выходной контент.</p>
                </div>
                <div class="info-card core-item anim-element anim-scale-in anim-delay-11">
                    <h3>
                        <svg viewBox="0 0 24 24"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>
                        Meta_Reviewer
                    </h3>
                    <p>Осуществляется **высокоуровневый системный надзор** за работой всех ядер Hecate и подготавливаются агрегированные данные для финальной Агора-делиберации.</p>
                </div>
            </div>
        </div>
    </section>

    <section id="agora" class="scroll-card">
        <div id="threejs-container-agora" class="card-3d-background"></div>
        <div class="card-content">
            <h2 class="anim-element anim-slide-up anim-delay-0">Модель Консенсуса "AGORA"</h2>
            <p class="section-description anim-element anim-fade-in anim-delay-1">"Agora" — это не просто процесс, а **динамическая цифровая площадь**, где специализированные агенты, вооружённые данными от ядер Hecate, ведут **интенсивные внутренние дискуссии**. Здесь происходит формирование коллективного разума через итеративное разрешение конфликтов и достижение оптимального консенсуса.</p>
            <div class="info-grid process-grid" style="counter-reset: process-step-counter;">
                <div class="info-card process-step anim-element anim-slide-up anim-delay-2">
                    <h3>1. Параллельная Генерация</h3>
                    <p>Все десять Hecate Cores одновременно и независимо генерируют свои уникальные аналитические и творческие перспективы, формируя первичный набор данных.</p>
                </div>
                <div class="info-card process-step anim-element anim-slide-up anim-delay-3">
                    <h3>2. Делиберация Агентов</h3>
                    <p>Специализированные агенты, каждый из которых представляет выход одного или нескольких ядер, входят в фазу интенсивного обсуждения, аргументируя свои позиции и выявляя потенциальные расхождения.</p>
                </div>
                <div class="info-card process-step anim-element anim-slide-up anim-delay-4">
                    <h3>3. Итеративное Разрешение Конфликтов</h3>
                    <p>Были обнаружены противоречия (фактические, логические, стилистические) и немедленно подвергаются анализу и разрешению через взвешенное голосование, приоритизацию данных и переформулирование, пока не будет достигнут консенсус.</p>
                </div>
                <div class="info-card process-step anim-element anim-slide-up anim-delay-5">
                    <h3>4. Синтез и Финальная Сборка</h3>
                    <p>После достижения консенсуса, все согласованные элементы собираются в единый, когерентный вывод, который затем передаётся для окончательной, критической валидации.</p>
                </div>
            </div>
        </div>
    </section>

    <section id="logos" class="scroll-card">
        <div id="threejs-container-logos" class="card-3d-background"></div>
        <div class="card-content">
            <h2 class="anim-element anim-slide-up anim-delay-0">Валидация "LOGOS": Непреклонный Стандарт Качества</h2>
            <p class="section-description anim-element anim-fade-in anim-delay-1">Прежде чем любой вывод будет представлен вам, он проходит **строжайшую и многомерную проверку** через механизм "Logos_Validator". Это не просто проверка, а **финальный, критический этап**, гарантирующий безупречное качество, полную безопасность и абсолютное соответствие всем поставленным задачам.</p>
            <ul class="info-grid logos-checklist">
                <li class="info-card anim-element anim-slide-up anim-delay-2">
                    <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></svg>
                    <span><strong>Фактическая Целостность:</strong> Абсолютная, непреклонная точность всех данных и утверждений, исключающая любые искажения.</span>
                </li>
                <li class="info-card anim-element anim-slide-up anim-delay-3">
                    <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></svg>
                    <span><strong>Логическая Когерентность:</strong> Идеальная последовательность, отсутствие противоречий и безупречная структура рассуждений.</span>
                </li>
                <li class="info-card anim-element anim-slide-up anim-delay-4">
                    <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></svg>
                    <span><strong>Соблюдение Правил:</strong> Полное и точное соответствие всем заданным параметрам, ограничениям и пользовательским директивам.</span>
                </li>
                <li class="info-card anim-element anim-slide-up anim-delay-5">
                    <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></svg>
                    <span><strong>Этическая Безопасность:</strong> Гарантия отсутствия любого потенциально вредоносного, предвзятого или дискриминационного контента.</span>
                </li>
                <li class="info-card anim-element anim-slide-up anim-delay-6">
                    <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></svg>
                    <span><strong>Полнота и Объем:</strong> Всеобъемлющее покрытие запроса, без упущений или недостающих компонентов, обеспечивающее исчерпывающий ответ.</span>
                </li>
                <li class="info-card anim-element anim-slide-up anim-delay-7">
                    <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></svg>
                    <span><strong>Эффективность и Краткость:</strong> Проверка на отсутствие избыточности, излишней детализации или "водянистости", обеспечивая оптимальную информационную плотность.</span>
                </li>
                <li class="info-card anim-element anim-slide-up anim-delay-8">
                    <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></svg>
                    <span><strong>Формат и Структура:</strong> Строгое соответствие запрошенному формату вывода (Markdown, JSON, LaTeX и т.d.) и его внутренней структуре.</span>
                </li>
            </ul>
        </div>
    </section>

    <section id="contact" class="scroll-card">
        <div id="threejs-container-contact" class="card-3d-background"></div>
        <div class="card-content">
            <h2 class="anim-element anim-slide-up anim-delay-0">Взаимодействие с G-B 11.0</h2>
            <p class="section-description anim-element anim-fade-in anim-delay-1">Готовность использовать возможности передового интеллекта? Свяжитесь со мной для начала вашего проекта или для получения дополнительной информации.</p>
            <form class="contact-form anim-element anim-slide-up anim-delay-2">
                <input type="text" placeholder="Ваше имя" required class="anim-element anim-fade-in anim-delay-3">
                <input type="email" placeholder="Ваш Email" required class="anim-element anim-fade-in anim-delay-4">
                <textarea placeholder="Ваше сообщение..." rows="6" required class="anim-element anim-fade-in anim-delay-5"></textarea>
                <button type="submit" class="btn anim-element anim-fade-in anim-delay-6">Отправить Запрос</button>
            </form>
            <footer class="main-footer">
                <p>&copy; 2025 Нейроинтерфейс G-B 11.0 "METIS-HECATE". Все права защищены. <br> Powered by Deeper Intellect Protocols.</p>
                <div class="footer-links">
                    <a href="#">Политика конфиденциальности</a>
                    <a href="#">Условия использования</a>
                    <a href="#">API Документация</a>
                </div>
            </footer>
        </div>
    </section>

    <div class="nav-indicators">
        </div>

    <script>
        // THREE.JS SCENE MANAGEMENT
        let currentScene = null;
        let currentCamera = null;
        let currentRenderer = null;
        let currentSceneData = null; // Store scene-specific objects (cubes, particles, etc.)

        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isMobileDevice = false;

        // Common Three.js assets (reused)
        const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const cubeMaterial = new THREE.MeshPhongMaterial({
            color: 0x6a05ad, // primary-color
            specular: 0x00d4ff, // accent-color for shine
            shininess: 50,
            transparent: true,
            opacity: 0.8
        });
        const particleBaseMaterial = new THREE.PointsMaterial({
            size: 0.08,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        const particleColors = [
            new THREE.Color(0x6a05ad),
            new THREE.Color(0x00d4ff),
            new THREE.Color(0xffffff)
        ];

        // --- SCENE DEFINITIONS ---
        // Each scene config returns { scene, camera, [other_objects_to_animate] }
        const sceneConfigs = [
            // Scene 0: Hero Section - Flying Cubes & Particles
            {
                id: 'hero',
                create: (container) => {
                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                    camera.position.z = 5;

                    const ambientLight = new THREE.AmbientLight(0x404040, 2); scene.add(ambientLight);
                    const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1); directionalLight1.position.set(1, 1, 1); scene.add(directionalLight1);
                    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5); directionalLight2.position.set(-1, -1, -1); scene.add(directionalLight2);
                    const pointLight = new THREE.PointLight(0x00d4ff, 2, 50); pointLight.position.set(0, 0, 5); scene.add(pointLight);

                    const cubes = [];
                    const numCubes = 80;
                    for (let i = 0; i < numCubes; i++) {
                        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial.clone());
                        cube.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
                        cube.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
                        cube.userData.initialPosition = cube.position.clone();
                        cubes.push(cube); scene.add(cube);
                    }

                    const particles = [];
                    const particleCount = 7000;
                    const posArray = new Float32Array(particleCount * 3);
                    const colorArray = new Float32Array(particleCount * 3);
                    for (let i = 0; i < particleCount * 3; i += 3) {
                        posArray[i] = (Math.random() - 0.5) * 40; posArray[i + 1] = (Math.random() - 0.5) * 40; posArray[i + 2] = (Math.random() - 0.5) * 40;
                        const color = particleColors[Math.floor(Math.random() * particleColors.length)];
                        colorArray[i] = color.r; colorArray[i + 1] = color.g; colorArray[i + 2] = color.b;
                    }
                    const pGeo = new THREE.BufferGeometry();
                    pGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                    pGeo.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
                    const pSystem = new THREE.Points(pGeo, particleBaseMaterial);
                    particles.push(pSystem); scene.add(pSystem);

                    return { scene, camera, cubes, particles };
                },
                animate: (data, scrollProgress) => {
                    data.scene.rotation.y += (targetRotationY - data.scene.rotation.y) * 0.05;
                    data.scene.rotation.x += (targetRotationX - data.scene.rotation.x) * 0.05;

                    data.cubes.forEach(cube => {
                        cube.rotation.x += 0.01; cube.rotation.y += 0.01; cube.rotation.z += 0.007;
                        cube.scale.set(1 + Math.sin(Date.now() * 0.001 + cube.id) * 0.05, 1 + Math.cos(Date.now() * 0.0012 + cube.id) * 0.05, 1 + Math.sin(Date.now() * 0.0015 + cube.id) * 0.05);
                        
                        // Move deeper into scene based on scroll
                        if (cube.userData.initialPosition) { // Ensure initial position is stored
                            cube.position.z = cube.userData.initialPosition.z - (scrollProgress * 20); 
                        }
                    });
                    data.particles.forEach(ps => {
                        const positions = ps.geometry.attributes.position.array;
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i + 2] += 0.05;
                            if (positions[i + 2] > data.camera.position.z + 5) {
                                positions[i + 2] = data.camera.position.z - 20;
                            }
                        }
                        ps.geometry.attributes.position.needsUpdate = true;
                    });
                }
            },
            // Scene 1: About Section - Neural Network / Data Flow
            {
                id: 'about',
                create: (container) => {
                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                    camera.position.z = 10;

                    const ambientLight = new THREE.AmbientLight(0xaaaaaa); scene.add(ambientLight);
                    const pointLight = new THREE.PointLight(0x00d4ff, 1.5, 100); pointLight.position.set(0, 0, 0); scene.add(pointLight);

                    const nodes = [];
                    const nodeMaterial = new THREE.MeshBasicMaterial({ color: 0xA300EF, transparent: true, opacity: 0.9 });
                    for (let i = 0; i < 70; i++) {
                        const node = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), nodeMaterial);
                        node.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
                        nodes.push(node); scene.add(node);
                    }

                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00E4FF, transparent: true, opacity: 0.5 });
                    const lines = [];
                    for (let i = 0; i < 150; i++) {
                        const lineGeometry = new THREE.BufferGeometry();
                        const positions = new Float32Array(6);
                        lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        lines.push(line); scene.add(line);
                    }

                    return { scene, camera, nodes, lines };
                },
                animate: (data) => {
                    data.camera.position.x += (targetRotationY * 5 - data.camera.position.x) * 0.05;
                    data.camera.position.y += (-targetRotationX * 5 - data.camera.position.y) * 0.05;
                    data.camera.lookAt(data.scene.position);

                    data.nodes.forEach(node => {
                        node.position.x += Math.sin(Date.now() * 0.0005 + node.id) * 0.02;
                        node.position.y += Math.cos(Date.now() * 0.0007 + node.id) * 0.02;
                        node.position.z += Math.sin(Date.now() * 0.0006 + node.id) * 0.02;
                    });

                    data.lines.forEach(line => {
                        const node1 = data.nodes[Math.floor(Math.random() * data.nodes.length)];
                        const node2 = data.nodes[Math.floor(Math.random() * data.nodes.length)];
                        const positions = line.geometry.attributes.position.array;
                        positions[0] = node1.position.x; positions[1] = node1.position.y; positions[2] = node1.position.z;
                        positions[3] = node2.position.x; positions[4] = node2.position.y; positions[5] = node2.position.z;
                        line.geometry.attributes.position.needsUpdate = true;
                    });
                }
            },
            // Scene 2: Hecate Section - Interconnected Grid with Energy Pulses
            {
                id: 'hecate',
                create: (container) => {
                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                    camera.position.z = 10;

                    const ambientLight = new THREE.AmbientLight(0x404040, 1.5); scene.add(ambientLight);
                    const dirLight = new THREE.DirectionalLight(0xffffff, 1); dirLight.position.set(5, 10, 7.5); scene.add(dirLight);

                    const spheres = [];
                    const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x00E4FF, specular: 0xffffff, shininess: 50 });
                    const numRows = 12, numCols = 12;
                    const spacing = 1.2;
                    for (let x = 0; x < numCols; x++) {
                        for (let y = 0; y < numRows; y++) {
                            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), sphereMaterial.clone());
                            sphere.position.set((x - numCols / 2) * spacing, (y - numRows / 2) * spacing, (Math.random() - 0.5) * 5);
                            spheres.push(sphere); scene.add(sphere);
                        }
                    }
                    return { scene, camera, spheres };
                },
                animate: (data) => {
                    data.camera.position.x += (targetRotationY * 5 - data.camera.position.x) * 0.05;
                    data.camera.position.y += (-targetRotationX * 5 - data.camera.position.y) * 0.05;
                    data.camera.lookAt(data.scene.position);

                    data.spheres.forEach(sphere => {
                        sphere.position.z = Math.sin(Date.now() * 0.001 + sphere.position.x * 0.5 + sphere.position.y * 0.5) * 0.8; // More pronounced wave
                        sphere.rotation.y += 0.008;
                    });
                    data.scene.rotation.z += 0.0015; // Faster overall rotation
                }
            },
            // Scene 3: Agora Section - Dynamic Particle Convergence
            {
                id: 'agora',
                create: (container) => {
                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                    camera.position.z = 15;

                    const ambientLight = new THREE.AmbientLight(0xcccccc); scene.add(ambientLight);
                    const pLight = new THREE.PointLight(0xA300EF, 3, 30); pLight.position.set(0, 0, 0); scene.add(pLight);

                    const particleGeo = new THREE.BufferGeometry();
                    const particleCount = 10000;
                    const posArray = new Float32Array(particleCount * 3);
                    const colorArray = new Float32Array(particleCount * 3);
                    for (let i = 0; i < particleCount * 3; i += 3) {
                        posArray[i] = (Math.random() - 0.5) * 40; posArray[i + 1] = (Math.random() - 0.5) * 40; posArray[i + 2] = (Math.random() - 0.5) * 40;
                        const color = particleColors[Math.floor(Math.random() * particleColors.length)];
                        colorArray[i] = color.r; colorArray[i + 1] = color.g; colorArray[i + 2] = color.b;
                    }
                    particleGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                    particleGeo.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
                    const pSystem = new THREE.Points(particleGeo, particleBaseMaterial);
                    scene.add(pSystem);
                    return { scene, camera, pSystem, initialPositions: posArray.slice() };
                },
                animate: (data) => {
                    data.camera.position.x += (targetRotationY * 5 - data.camera.position.x) * 0.05;
                    data.camera.position.y += (-targetRotationX * 5 - data.camera.position.y) * 0.05;
                    data.camera.lookAt(data.scene.position);
                    
                    const positions = data.pSystem.geometry.attributes.position.array;
                    const speed = 0.05;
                    for (let i = 0; i < positions.length; i += 3) {
                        const targetX = 0; const targetY = 0; const targetZ = 0;
                        positions[i] += (targetX - positions[i]) * speed;
                        positions[i + 1] += (targetY - positions[i + 1]) * speed;
                        positions[i + 2] += (targetZ - positions[i + 2]) * speed;

                        if (positions[i] * positions[i] + positions[i+1] * positions[i+1] + positions[i+2] * positions[i+2] < 1) {
                            positions[i] = data.initialPositions[i];
                            positions[i + 1] = data.initialPositions[i + 1];
                            positions[i + 2] = data.initialPositions[i + 2];
                        }
                    }
                    data.pSystem.geometry.attributes.position.needsUpdate = true;
                }
            },
            // Scene 4: Logos Section - Abstract Energy Field / Grid
            {
                id: 'logos',
                create: (container) => {
                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                    camera.position.z = 10;

                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); scene.add(ambientLight);
                    const dirLight = new THREE.DirectionalLight(0x00E4FF, 1); dirLight.position.set(0, 0, 10); scene.add(dirLight);

                    const planeGeometry = new THREE.PlaneGeometry(30, 30, 60, 60);
                    const planeMaterial = new THREE.MeshBasicMaterial({
                        color: 0x6D00B8, // Dark purple
                        wireframe: true,
                        transparent: true,
                        opacity: 0.3
                    });
                    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                    plane.rotation.x = -Math.PI / 2;
                    plane.position.y = -5;
                    scene.add(plane);

                    return { scene, camera, plane };
                },
                animate: (data) => {
                    data.camera.position.x += (targetRotationY * 5 - data.camera.position.x) * 0.05;
                    data.camera.position.y += (-targetRotationX * 5 - data.camera.position.y) * 0.05;
                    data.camera.lookAt(data.scene.position);

                    const positionAttribute = data.plane.geometry.attributes.position;
                    for (let i = 0; i < positionAttribute.count; i++) {
                        const z = 0.5 * Math.sin(positionAttribute.getX(i) * 2 + Date.now() * 0.002) +
                                  0.5 * Math.cos(positionAttribute.getY(i) * 2 + Date.now() * 0.0015);
                        positionAttribute.setZ(i, z);
                    }
                    positionAttribute.needsUpdate = true;
                }
            },
            // Scene 5: Contact Section - Abstract Spheres & Lines (Web of Contact)
            {
                id: 'contact',
                create: (container) => {
                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                    camera.position.z = 8;

                    const ambientLight = new THREE.AmbientLight(0xffffff, 1); scene.add(ambientLight);
                    const pLight = new THREE.PointLight(0x00E4FF, 1.5, 30); pLight.position.set(0, 5, 0); scene.add(pLight);

                    const sphereGeo = new THREE.SphereGeometry(0.8, 16, 16); // Slightly smaller, less detailed spheres for performance
                    const sphereMat = new THREE.MeshPhongMaterial({ color: 0xA300EF, specular: 0xffffff, shininess: 80, transparent: true, opacity: 0.9 });
                    const spheres = [];
                    for(let i = 0; i < 8; i++) { // Fewer spheres
                        const sphere = new THREE.Mesh(sphereGeo, sphereMat.clone());
                        sphere.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                        spheres.push(sphere); scene.add(sphere);
                    }

                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00E4FF, transparent: true, opacity: 0.3 });
                    const lines = [];
                    for(let i = 0; i < 20; i++) { // Fewer lines
                        const lineGeometry = new THREE.BufferGeometry();
                        const positions = new Float32Array(6);
                        lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        lines.push(line); scene.add(line);
                    }

                    return { scene, camera, spheres, lines };
                },
                animate: (data) => {
                    data.camera.position.x += (targetRotationY * 3 - data.camera.position.x) * 0.05;
                    data.camera.position.y += (-targetRotationX * 3 - data.camera.position.y) * 0.05;
                    data.camera.lookAt(data.scene.position);

                    data.spheres.forEach(sphere => {
                        sphere.rotation.x += 0.008; sphere.rotation.y += 0.005;
                        sphere.position.x += Math.sin(Date.now() * 0.001 + sphere.id) * 0.015;
                        sphere.position.y += Math.cos(Date.now() * 0.0008 + sphere.id) * 0.015;
                    });

                    // Update lines between random spheres
                    data.lines.forEach(line => {
                        const s1 = data.spheres[Math.floor(Math.random() * data.spheres.length)];
                        const s2 = data.spheres[Math.floor(Math.random() * data.spheres.length)];
                        const positions = line.geometry.attributes.position.array;
                        positions[0] = s1.position.x; positions[1] = s1.position.y; positions[2] = s1.position.z;
                        positions[3] = s2.position.x; positions[4] = s2.position.y; positions[5] = s2.position.z;
                        line.geometry.attributes.position.needsUpdate = true;
                    });
                }
            }
        ];

        // Function to set up the active scene
        const setupScene = (index) => {
            if (currentRenderer && currentSceneIndex !== index) { // Only change if different scene
                // Dispose of current scene resources
                if (currentSceneData) {
                    currentSceneData.scene.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                        currentSceneData.scene.remove(child);
                    });
                }
                currentRenderer.dispose();
                // Remove existing canvas
                const oldCanvas = document.querySelector('.threejs-canvas-instance');
                if (oldCanvas) oldCanvas.remove();
                console.log(`Disposed scene ${sceneConfigs[currentSceneIndex]?.id}`);
            }

            currentSceneIndex = index;
            const config = sceneConfigs[index];
            const containerId = `threejs-container-${config.id}`;
            const container = document.getElementById(containerId);

            if (!container) {
                console.error(`Container for scene ${config.id} not found.`);
                return;
            }

            // Create new canvas for the current scene
            const newCanvas = document.createElement('canvas');
            newCanvas.id = `threejs-canvas-${config.id}`; // Unique ID for debugging
            newCanvas.className = 'threejs-canvas-instance';
            container.appendChild(newCanvas);

            currentRenderer = new THREE.WebGLRenderer({ canvas: newCanvas, antialias: true, alpha: true });
            currentRenderer.setSize(container.clientWidth, container.clientHeight);
            currentRenderer.setPixelRatio(window.devicePixelRatio);
            currentRenderer.domElement.style.width = '100%'; // Ensure canvas fills container
            currentRenderer.domElement.style.height = '100%';

            currentSceneData = config.create(container); // Pass container for dimensions
            currentScene = currentSceneData.scene;
            currentCamera = currentSceneData.camera;
            
            // Store initial positions for cubes if they exist (important for Hero scene)
            if (currentSceneData.cubes) {
                currentSceneData.cubes.forEach(cube => {
                    cube.userData.initialPosition = cube.position.clone();
                });
            }

            // Update on resize
            window.addEventListener('resize', () => { // Attach to window, not renderer.domElement
                currentCamera.aspect = container.clientWidth / container.clientHeight;
                currentCamera.updateProjectionMatrix();
                currentRenderer.setSize(container.clientWidth, container.clientHeight);
            });
            console.log(`Scene for ${config.id} initialized.`);
        };

        // Main Animation Loop
        function animateAllScenes() {
            requestAnimationFrame(animateAllScenes);

            if (currentRenderer && currentScene && currentCamera && currentSceneData) {
                const scrollProgress = window.pageYOffset / (document.body.scrollHeight - window.innerHeight);
                
                // Animate the current scene based on its config
                if (sceneConfigs[currentSceneIndex] && sceneConfigs[currentSceneIndex].animate) {
                    sceneConfigs[currentSceneIndex].animate(currentSceneData, scrollProgress);
                }

                currentRenderer.render(currentScene, currentCamera);
            }
        }
        animateAllScenes(); // Start the main animation loop

        // DOMContentLoaded and other JS logic
        document.addEventListener('DOMContentLoaded', () => {
            // --- Гироскоп/Mouse Input Setup (request permission if needed) ---
            isMobileDevice = /Mobi|Android/i.test(navigator.userAgent);

            if (window.DeviceOrientationEvent && isMobileDevice) {
                const requestPermission = () => {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    window.addEventListener('deviceorientation', handleOrientation);
                                    console.log("DeviceOrientationEvent permission granted.");
                                } else {
                                    console.warn("DeviceOrientationEvent permission denied.");
                                    window.addEventListener('mousemove', onMouseMove); // Fallback to mouse
                                }
                            })
                            .catch(console.error);
                    } else {
                        window.addEventListener('deviceorientation', handleOrientation);
                        console.log("DeviceOrientationEvent listener added directly.");
                    }
                };
                // Prompt permission on first meaningful user interaction, e.g., on a specific button click
                // For scroll-snap, it's harder to tie to a "click", so we might need a visible prompt.
                // For now, it will be called below on the first scroll/active card.
                let permissionRequested = false;
                 // Add a hidden button for iOS 13+ permission if needed (best practice)
                const permissionButton = document.createElement('button');
                permissionButton.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999; padding: 15px 30px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 5px; cursor: pointer; display: none;';
                permissionButton.textContent = 'Разрешить доступ к сенсорам';
                document.body.appendChild(permissionButton);

                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    permissionButton.style.display = 'block'; // Show button to request permission
                    permissionButton.addEventListener('click', () => {
                        requestPermission();
                        permissionButton.style.display = 'none';
                    });
                } else if (isMobileDevice) {
                    // For non-iOS 13+ devices, try to get permission immediately if mobile
                     requestPermission();
                }
            } else {
                window.addEventListener('mousemove', onMouseMove);
                console.log("Mousemove listener added for desktop control.");
            }

            function handleOrientation(event) {
                const b = event.beta; // In X-axis, -180 to 180
                const g = event.gamma; // In Y-axis, -90 to 90

                // Map to -1 to 1 range, adjust sensitivity
                targetRotationY = (g / 90) * 0.8; // Max 90 degrees left/right
                targetRotationX = (b / 90) * 0.8;  // Max 90 degrees front/back
            }

            function onMouseMove(event) {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = - (event.clientY / window.innerHeight) * 2 + 1;

                targetRotationY = mouseX * 0.5;
                targetRotationX = mouseY * 0.5;
            }

            // --- Scroll-snap and Intersection Observer for Card Activation ---
            const scrollCards = document.querySelectorAll('.scroll-card');
            const navIndicatorsContainer = document.querySelector('.nav-indicators');
            let activeCardIndex = 0; // Track active card

            // Populate nav indicators
            scrollCards.forEach((card, index) => {
                const dot = document.createElement('div');
                dot.classList.add('nav-dot');
                dot.dataset.index = index;
                dot.addEventListener('click', () => {
                    card.scrollIntoView({ behavior: 'smooth' });
                });
                navIndicatorsContainer.appendChild(dot);
            });

            const updateNavIndicators = () => {
                document.querySelectorAll('.nav-dot').forEach((dot, index) => {
                    if (index === activeCardIndex) {
                        dot.classList.add('active');
                    } else {
                        dot.classList.remove('active');
                    }
                });
            };

            // Intersection Observer to detect which card is active
            const cardObserverCallback = (entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio >= 0.75) { // Card is mostly visible
                        const index = Array.from(scrollCards).indexOf(entry.target);
                        if (index !== activeCardIndex) {
                            activeCardIndex = index;
                            updateNavIndicators();
                            setupScene(activeCardIndex); // Initialize/switch Three.js scene for active card
                            
                            // Vibrate on card change (conceptual haptic feedback)
                            if (navigator.vibrate) {
                                navigator.vibrate(50); // Short vibration
                            }
                        }
                        entry.target.classList.add('active'); // Activate content animation
                    } else {
                        entry.target.classList.remove('active');
                    }
                });
            };

            const cardObserverOptions = {
                root: null,
                threshold: [0.25, 0.5, 0.75, 1] // Observe when 25%, 50%, 75%, 100% of card is visible
            };

            const cardObserver = new IntersectionObserver(cardObserverCallback, cardObserverOptions);

            scrollCards.forEach(card => {
                cardObserver.observe(card);
            });

            // Initial setup for the first card
            if (scrollCards.length > 0) {
                activeCardIndex = 0;
                updateNavIndicators();
                setupScene(activeCardIndex); // Ensure first scene is set up immediately
                scrollCards[0].classList.add('active'); // Activate first card's content
            }

            // --- Window Resize Listener ---
            window.addEventListener('resize', () => {
                if (currentCamera && currentRenderer) {
                    const container = document.getElementById(`threejs-container-${sceneConfigs[currentSceneIndex]?.id}`);
                    if (container) {
                        currentCamera.aspect = container.clientWidth / container.clientHeight;
                        currentCamera.updateProjectionMatrix();
                        currentRenderer.setSize(container.clientWidth, container.clientHeight);
                    }
                }
            });
        });
    </script>
</body>
</html>
